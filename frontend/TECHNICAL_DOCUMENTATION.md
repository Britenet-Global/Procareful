# Procareful Technical Documentation

This document provides in-depth technical details about the Procareful project architecture, implementation patterns, and development guidelines. It is intended for developers who will be working on the codebase.

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [State Management](#state-management)
3. [API Integration](#api-integration)
4. [Routing and Navigation](#routing-and-navigation)
5. [Internationalization](#internationalization)
6. [Component Structure](#component-structure)
7. [Authentication and Authorization](#authentication-and-authorization)
8. [Games Implementation](#games-implementation)
9. [Development Workflow](#development-workflow)
10. [Performance Considerations](#performance-considerations)

## Architecture Overview

The Procareful project is built as a monorepo using NX, with a clear separation of concerns between applications and shared libraries:

### Applications

- **Procareful PWA** (`apps/procareful`): Progressive Web App for senior users
- **Procareful Admin** (`apps/procareful-admin`): Administration panel for caregivers and administrators

### Shared Libraries

- **Common** (`libs/common`): Shared utilities, API integration, i18n, hooks, and constants
- **Games** (`libs/games`): Cognitive games implementations
- **UI** (`libs/ui`): Reusable UI components

### Key Architectural Patterns

1. **Component-Based Architecture**: The application is built using React components with a clear hierarchy.
2. **Container/Presentation Pattern**: Many components are separated into container (logic) and presentation (UI) components.
3. **Custom Hooks**: Business logic is often extracted into custom hooks for reusability.
4. **Centralized Routing**: Routes are defined centrally and organized by access level.
5. **API Layer Abstraction**: API calls are abstracted through generated services.

## State Management

The project uses Zustand for state management, providing a lightweight and flexible approach to managing application state.

### Zustand Store Implementation

Stores are typically organized by feature or domain and follow this pattern:

```typescript
// Example store implementation
import { create } from 'zustand';

type ExampleStore = {
  // State properties
  someValue: string;
  isLoading: boolean;

  // Actions
  setValue: (value: string) => void;
  setLoading: (isLoading: boolean) => void;
  resetState: () => void;
};

const initialState = {
  someValue: '',
  isLoading: false,
};

export const useExampleStore = create<ExampleStore>(set => ({
  ...initialState,
  setValue: value => set({ someValue: value }),
  setLoading: isLoading => set({ isLoading }),
  resetState: () => set({ ...initialState }),
}));
```

### Key Stores

1. **Auth Store**: Manages authentication state
2. **Game Stores**: Each game has its own store for game state
3. **UI Stores**: Manage UI state like modals, notifications, etc.

### Best Practices

- Keep stores focused on a specific domain or feature
- Use the `set` function for state updates
- Provide reset functionality for cleanup
- Consider using middleware like `persist` for state persistence when needed
- Use selectors to access specific parts of the state to avoid unnecessary rerenders

## API Integration

The project uses Orval for API code generation based on OpenAPI specifications, integrated with TanStack Query (React Query) for data fetching, caching, and state management.

### API Code Generation

API client code is automatically generated using Orval:

```typescript
// orval.config.ts configuration
export default defineConfig({
  procareful: {
    input: {
      target: `${process.env.VITE_ORVAL_BASE_URL}/api/swagger-spec.json`,
    },
    output: {
      baseUrl: process.env.VITE_BASE_URL,
      workspace: './libs/common/src/api/',
      mode: 'split',
      target: `services.ts`,
      client: 'react-query',
      mock: false,
      override: {
        useNativeEnums: true,
        header: info => [
          `Generated by orval ðŸº`,
          `Do not edit manually.`,
          ...(info.title ? [info.title] : []),
          ...(info.description ? [info.description] : []),
          ...(info.version ? [`OpenAPI spec version: ${info.version}`] : []),
          'eslint-disable',
        ],
        mutator: {
          path: 'axios.ts',
          name: 'axiosWrapper',
        },
        query: {
          useQuery: true,
        },
      },
    },
  },
});
```

### Axios Configuration

The project uses a custom Axios instance with interceptors for handling authentication and error responses:

```typescript
export const axiosInstance = axios.create({
  withCredentials: true,
  headers: {
    'Accept-Language': 'en-US',
  },
});

axiosInstance.interceptors.response.use(
  response => response,
  error => {
    if (
      error.response &&
      (error.response.status === HttpStatusCode.Unauthorized ||
        error.response.status === HttpStatusCode.Forbidden)
    ) {
      localStorage.removeItem(LocalStorageKey.IsAuthenticated);
      useAuthStore.getState().setAuthState({ isAuth: false, isLoading: false });
    }

    return Promise.reject(error);
  }
);
```

### React Query Configuration

The project uses a custom QueryClient configuration with global error handling:

```typescript
export const queryClient: QueryClient = new QueryClient({
  queryCache: new QueryCache({
    onError: (error, query) => {
      // Error handling logic
      // ...
    },
  }),
  // Additional configuration
});
```

### Best Practices

1. **Use Generated Hooks**: Always use the generated query hooks from Orval
2. **Handle Loading States**: Always handle loading states in UI components
3. **Error Handling**: Implement proper error handling for API calls
4. **Invalidation**: Properly invalidate queries when data changes
5. **Prefetching**: Consider prefetching data for better UX

## Routing and Navigation

### Route Configuration

Routes are defined centrally and organized by access level:

#### Procareful PWA

Routes are defined in `apps/procareful/src/app/constants/routes.tsx`:

```typescript
// Protected routes example
export const protectedRoutes = [
  {
    path: ProcarefulAppPathRoutes.Dashboard,
    element: <Dashboard />,
  },
  // Other routes...
];

// Public routes example
export const publicRoutes = [
  {
    path: ProcarefulAppPathRoutes.LoginMethod,
    element: <LoginMethod />,
  },
  // Other routes...
];
```

#### Procareful Admin

Routes are defined in `apps/procareful-admin/src/app/constants/routes.tsx` with role-based access control:

```typescript
export const protectedRoutes: Route[] = [
  {
    paths: [PathRoutes.Dashboard],
    element: <Dashboard />,
    access: [
      AdminRolesDtoRoleName.formalCaregiver,
      AdminRolesDtoRoleName.informalCaregiver,
      AdminRolesDtoRoleName.adminInstitution,
      AdminRolesDtoRoleName.superAdminInstitution,
    ],
  },
  // Other routes...
];
```

### Route Protection

The admin panel uses a `ProtectedRoute` component for access control:

```typescript
const ProtectedRoute = ({
  isAuthenticated,
  isAuthorized,
  redirectPath,
  children,
}: ProtectedRouteProps) => {
  if (!isAuthenticated) {
    return <Navigate to={redirectPath} replace />;
  }

  if (!isAuthorized) {
    return <Navigate to={PathRoutes.NotFound} replace />;
  }

  return children;
};
```

### Navigation

Navigation is handled using React Router's hooks:

```typescript
const navigate = useNavigate();

// Simple navigation
navigate(PathRoutes.Dashboard);

// Navigation with parameters
navigate({
  pathname: PathRoutes.SeniorProfile,
  search: new URLSearchParams({
    [SearchParams.Id]: seniorId,
  }).toString(),
});
```

## Internationalization

The project uses i18next for internationalization with a structured approach to translation keys.

### i18n Configuration

```typescript
// i18n.config.ts
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import { en, pl, de, hr, hu, it, si } from './translations';

export const resources = {
  en,
  pl,
  de,
  hr,
  hu,
  it,
  si,
};

i18n.use(initReactI18next).init({
  compatibilityJSON: 'v3',
  resources,
  fallbackLng: 'en',
  defaultNS: 'translations',
  lowerCaseLng: true,
  interpolation: {
    escapeValue: false,
  },
  react: {
    useSuspense: false,
  },
});
```

### Translation Key Structure

Translation keys follow a structured naming convention:

- **Prefixes**: `'admin' | 'shared' | 'senior'`
- **SubPrefixes**: `'btn' | 'title' | 'form' | 'inf' | 'alert' | 'table'`
- **Pattern**: `${Prefixes}_${SubPrefixes}_${string}`

Example:

```typescript
// Translation key example
"admin_form_note_attachments_counter": "{{count}} attachment", // singular
"admin_form_note_attachments_counter_plural": "{{count}} attachments", // plural
```

### Typed Translations

The project uses a custom hook for typed translations:

```typescript
export const useTypedTranslation = <T>(): {
  t: (key: Key, options?: CustomTranslationOptions<T>) => string;
  i18n: i18n;
} => {
  const { t: tt, i18n } = useTranslation();
  const t = (key: Key, options?: CustomTranslationOptions<T>) => tt(key, options);
  return { t, i18n };
};
```

### Translation Synchronization

The project includes a script to synchronize translation files:

```javascript
// syncTranslations.js
const synchronizeTranslations = (folderPath, masterFile) => {
  const masterFilePath = path.join(folderPath, masterFile);
  const masterData = loadJsonFile(masterFilePath);
  const masterKeys = new Set(Object.keys(masterData.translations));

  fs.readdirSync(folderPath).forEach(file => {
    if (file !== masterFile && path.extname(file) === '.json') {
      const filePath = path.join(folderPath, file);
      const fileData = loadJsonFile(filePath);

      // Add missing keys
      masterKeys.forEach(key => {
        if (!(key in fileData.translations)) {
          fileData.translations[key] = '';
        }
      });

      // Remove obsolete keys
      Object.keys(fileData.translations).forEach(key => {
        if (!masterKeys.has(key)) {
          delete fileData.translations[key];
        }
      });

      saveJsonFile(filePath, fileData);
    }
  });
};
```

## Component Structure

The project follows a consistent component structure across the codebase:

### Folder Structure

```
ComponentName/
â”œâ”€â”€ ComponentName.tsx       # Component implementation
â”œâ”€â”€ ComponentName.styles.ts # Styles using antd-style
â”œâ”€â”€ index.ts               # Re-export for cleaner imports
```

### Component Implementation Pattern

```typescript
// Component example
import { type FC } from 'react';
import { useStyles } from './ComponentName.styles';

export interface ComponentNameProps {
  // Props definition
}

export const ComponentName: FC<ComponentNameProps> = ({ prop1, prop2 }) => {
  const { styles } = useStyles();

  // Component logic

  return (
    <div className={styles.container}>
      {/* Component JSX */}
    </div>
  );
};
```

### Styling Pattern

The project uses antd-style for component styling:

```typescript
// Styling example
import { createStyles } from 'antd-style';

export const useStyles = createStyles(({ css, token }) => ({
  container: css`
    display: flex;
    flex-direction: column;
    padding: ${token.padding}px;
  `,
  // Other styles
}));
```

## Authentication and Authorization

### Authentication Flow

1. User enters credentials (email/phone)
2. Confirmation code is sent to the user
3. User enters the confirmation code
4. Backend validates the code and returns authentication tokens
5. Frontend stores authentication state in local storage and Zustand store

### Auth Store

```typescript
type AuthState = {
  isAuth: boolean;
  isLoading: boolean;
};

type AuthStore = {
  authState: AuthState;
  setAuthState: (authState: Partial<AuthState>) => void;
};

export const useAuthStore = create<AuthStore>(set => ({
  authState: {
    isAuth: localStorage.getItem(LocalStorageKey.IsAuthenticated) === 'true',
    isLoading: true,
  },
  setAuthState: authState =>
    set(state => ({
      authState: { ...state.authState, ...authState },
    })),
}));
```

### Authorization

The admin panel implements role-based access control:

```typescript
// Role verification
export const verifyAccessByRole = (
  requiredRoles: AdminRolesDtoRoleName[],
  userRoles: AdminRolesDtoRoleName[]
): boolean => {
  if (!requiredRoles || requiredRoles.length === 0) {
    return true;
  }

  return requiredRoles.some(role => userRoles.includes(role));
};
```

## Games Implementation

The games library (`libs/games`) contains implementations of various cognitive games, each following a similar structure:

### Game Structure

```
GameName/
â”œâ”€â”€ components/           # Game-specific components
â”œâ”€â”€ constants.ts          # Game constants
â”œâ”€â”€ helpers.ts            # Helper functions
â”œâ”€â”€ store/                # Game state management
â”‚   â””â”€â”€ gameNameStore.ts  # Zustand store
â”œâ”€â”€ types/                # Game-specific types
â”œâ”€â”€ index.ts              # Re-export for cleaner imports
â””â”€â”€ GameName.tsx          # Main game component
```

### Game State Management

Each game has its own Zustand store for state management:

```typescript
// Example game store
type GameStore = {
  // Game state
  score: number;
  isGameOver: boolean;

  // Game actions
  incrementScore: () => void;
  endGame: () => void;
  resetGame: () => void;
};

export const useGameStore = create<GameStore>(set => ({
  score: 0,
  isGameOver: false,

  incrementScore: () => set(state => ({ score: state.score + 1 })),
  endGame: () => set({ isGameOver: true }),
  resetGame: () => set({ score: 0, isGameOver: false }),
}));
```

### Game Components

Game components are typically structured to handle:

1. Game initialization
2. Game loop
3. User input
4. Game rendering
5. Game over conditions
6. Score tracking
7. Tutorial/help screens

## Development Workflow

### Local Development

1. **Setup Environment**:

   ```bash
   # Install dependencies
   npm install

   # Copy environment variables
   cp .env.example .env
   ```

2. **Start Development Server**:

   ```bash
   # For senior app
   npm start procareful

   # For admin panel
   npm start procareful-admin
   ```

3. **Generate API Client**:
   ```bash
   npm run generate-api
   ```

### Code Quality

1. **Linting**:

   ```bash
   # Check linting
   npm run lint

   # Fix linting issues
   npm run lint:fix
   ```

2. **Formatting**:

   ```bash
   # Check formatting
   npm run prettier

   # Fix formatting issues
   npm run prettier:fix
   ```

3. **Type Checking**:
   TypeScript is used throughout the project with strict type checking.

### Building for Production

```bash
# Build senior app
npm run build:procareful

# Build admin panel
npm run build:procareful-admin

# Build all apps
npm run build:all-apps
```

## Performance Considerations

### Memoization

Use React's memoization features to prevent unnecessary re-renders:

```typescript
// Component memoization
import { memo } from 'react';
// Hook memoization
import { useMemo, useCallback } from 'react';

export const MemoizedComponent = memo(({ prop1, prop2 }) => {
  // Component implementation
});

const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
const memoizedCallback = useCallback(() => doSomething(a, b), [a, b]);
```

### Code Splitting

The project uses React's lazy loading for code splitting:

```typescript
import { lazy, Suspense } from 'react';

const LazyComponent = lazy(() => import('./LazyComponent'));

const App = () => (
  <Suspense fallback={<Loader />}>
    <LazyComponent />
  </Suspense>
);
```

### React Query Optimization

Optimize React Query usage for better performance:

1. **Caching**: Configure appropriate cache times
2. **Stale While Revalidate**: Use stale-while-revalidate pattern
3. **Prefetching**: Prefetch data when appropriate
4. **Pagination**: Implement proper pagination for large data sets

### Bundle Size Optimization

1. **Tree Shaking**: Ensure proper imports to enable tree shaking
2. **Dynamic Imports**: Use dynamic imports for large dependencies
3. **Bundle Analysis**: Regularly analyze bundle size with tools like `webpack-bundle-analyzer`
